java jar包下载网址：https://mvnrepository.com/
https://blog.csdn.net/yongqi_wang/article/details/80469869
1、SSM,使用MyBatis Generator自动创建代码
参考：https://blog.csdn.net/zhshulin/article/details/23912615
2、Spring boot:
https://www.cnblogs.com/ityouknow/p/5662753.html
--------------------------------------学习框架，重点是要理解项目的思想--------------------------------------------------------
知识点：
一、MyBatis:
1、MyBatis是一个持久层框架，完成的是对数据库的访问和操作（CRUD）
2、它解决JDBC对数据库的操作和访问过程中存在的问题，是对原有JDBC技术的封装
   1、虽然JDBC操作数据库的方式很直观，但它的核心是对数据库的操作，多个方法间存在大量的冗余；
   2、基于Java中面向对象的基本思想，所以我们会将查询出来的结果封装成一个对象，这一系列操作都需要手动完成，将对象和表单做一个映射关系，
   将一个个属性取出来并赋值给对象，手动ORM映射
   3、对于多个用户的相同查询操作，没有进行优化，会造成运行效率偏低（主要指缓存层Cache）
3、以.xml配置文件的方式实现DAO接口去除冗余代码
运行原理：
MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactry再根据配置，获取一个SqlSession，配置来源于两个地方，一个是
配置文件，一个是源于Java代码的注解。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的
CRUD操作和事物提交，完成后关闭。
---------------------------------------------------------------------------------------------------------------------------
参考：https://javadoop.com/post/spring-ioc
二、Spring:
一个2003年兴起的轻量级开源框架，是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架；
三、SpringMVC
其属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面，其分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让他们更容易定制。

四、Spring IOC(控制反转)的理解
参考至：https://jinnianshilongnian.iteye.com/blog/1413846
       https://www.cnblogs.com/xdp-gacl/p/4249939.html 
    首先，IOC不是一种技术，而是一种思想，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部
直接控制。
    在传统的JAVA SE 程序设计中，我们直接在对象内部new进行对象创建，是程序主动去创建依赖对象，而IOC是有专门容器来控制对象的创建，即由IOC容器控制了对象，进行
外部资源获取。
Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，
把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，
而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。
五、SqlSession解读-核心
参考：https://blog.csdn.net/doujinlong1/article/details/81155650
六、Spring 框架的设计理念与设计模式分析
参考：https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/
-----------------------------------------------------------------------------------------------------------------------------
七、Spring AOP 和 IOC的再理解
AOP，即面向切面编程，基于代理模式，但JDK的动态代理模式只能代理接口而不能代理类，因此Spring AOP的切换方式如下：
1、如果目标对象的实现类实现了接口，Spring AOP将会采用JDK动态代理来生成AOP代理类；
2、如果目标对象的实现类没有实现接口，Spring AOP将会采用CGLIB来生成AOP代理类。
于此，会产生的问题是---什么是 静态代理？JDK动态代理？CGLIB动态代理？
-------AOP入门内容----------
在面向对象编程中的基本单位是类和实例，而AOP中的基本单位当然就是切面。
那什么是切面？其定义如下：
面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）
进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。
即，AOP其实是将系统的业务逻辑和系统服务（日志、安全等）进行了分离，为什么要分离其实进行过系统开发的人员都不难理解。而AOP实现这样的逻辑，是将非业务
逻辑功能拆分开，在系统运行时在需要的地方 动态 插入运行，不需要的时候就不理。
一些概念：
1、通知（Adivce）
2、切点（Pointcut），对应系统中的方法，但这个方法是定义在切面中的方法，一般和通知一起使用，组成切面。
3、连接点（Join point）,简单理解就是你准备在系统中执行切点和切入通知的地方（一般是一个方法，一个字段）。
4、切面（Aspect）,切面是切点和通知的集合，一般单独作为一个类，他们共同定义了在何时、何处完成功能。
5、引入（Introduction），引用允许我们向现有的类添加新的方法和属性。
6、织入（Weaving）
AOP语法：
可参考：https://www.cnblogs.com/zhangxufeng/p/9160869.html
AOP原理：
运行时织入，动态代理（基于接口代理实现--JDK代理和基于继承代理实现--Cglib代理）和静态代理模式。目标对象委托代理对象和caller端进行交互。caller端通过
接口interface来引用目标对象，而代理对象和代理对象共同作为接口的实现类，但代理对象把真正的方法交个委托对象来执行，自己执行额外逻辑，
也就是AOP要执行的逻辑。
JDK代理：
1、类：java.lang.reflect.Proxy
2、接口:InvocationHandler
3、只能基于接口进行动态代理；
Cglib代理：
有一个问题：spring在创建bean时，如何选择动态代理？是JDK代理还是Cglib代理？
1、如果目标对象接口实现了接口，则默认采用JDK代理；
2、如果目标对象没有实现接口，则采用Cglib进行动态代理；
3、如果目标对象也实现了接口，但是强制使用Cglib代理，则使用Cglib进行动态代理；
如何启动Cglib？ @EnableAspectJAutoProxy(proxyTargetClass=true)

另一个问题：多个AOP如何叠加？
使用责任链模式。
-----------------------IOC原理------------------------
Ioc，即控制反转，通过第三方的Ioc容器，实现多个具有依赖关系的对象解耦。
通俗的理解是：
对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”。
控制被反转之后，获取依赖对象的过程，由自身管理变为有IOC容器去管理。
spring通过Ioc容器，实现Core 组件、Bean 组件和 Context 组件构建起Bean的关系网。







